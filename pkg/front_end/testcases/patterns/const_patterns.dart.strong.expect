library /*isNonNullableByDefault*/;
//
// Problems in library:
//
// pkg/front_end/testcases/patterns/const_patterns.dart:26:12: Error: Method invocation is not a constant expression.
//       case super(): // Error
//            ^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:37:13: Error: Only negation of a numeric literal is supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//       case -value: // Error
//             ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:39:13: Error: Only negation of a numeric literal is supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//       case -local: // Error
//             ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:42:13: Error: Only negation of a numeric literal is supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//       case -prefix.value: // Error
//             ^^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:42:20: Error: Only negation of a numeric literal is supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//       case -prefix.value: // Error
//                    ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:44:14: Error: Expected ':' before this.
//       case 1 + 2: // Error
//              ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:44:14: Error: '+' is not a prefix operator.
// Try removing '+'.
//       case 1 + 2: // Error
//              ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:44:16: Error: Expected ';' after this.
//       case 1 + 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:44:17: Error: Expected an identifier, but got ':'.
// Try inserting an identifier before ':'.
//       case 1 + 2: // Error
//                 ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:44:17: Error: Unexpected token ':'.
//       case 1 + 2: // Error
//                 ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:45:14: Error: Expected ':' before this.
//       case 1 * 2: // Error
//              ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:45:14: Error: Expected an identifier, but got '*'.
// Try inserting an identifier before '*'.
//       case 1 * 2: // Error
//              ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:45:16: Error: Expected ';' after this.
//       case 1 * 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:45:17: Error: Expected an identifier, but got ':'.
// Try inserting an identifier before ':'.
//       case 1 * 2: // Error
//                 ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:45:17: Error: Unexpected token ':'.
//       case 1 * 2: // Error
//                 ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:46:20: Error: Expected ':' before this.
//       case void fun() {}: // Error
//                    ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:46:24: Error: Expected ';' after this.
//       case void fun() {}: // Error
//                        ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:46:25: Error: Expected an identifier, but got ':'.
// Try inserting an identifier before ':'.
//       case void fun() {}: // Error
//                         ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:46:25: Error: Unexpected token ':'.
//       case void fun() {}: // Error
//                         ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:47:12: Error: `assert` can't be used as an expression.
//       case assert(false): // Error
//            ^^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:48:20: Error: Not a constant expression.
//       case switch (o) { _ => true }: // Error
//                    ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:50:12: Error: The unary operator ! is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//       case !false: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:51:12: Error: The unary operator ~ is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//       case ~0: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:52:14: Error: Not a constant expression.
//       case ++variable: // Error
//              ^^^^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:53:18: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//       case const 0: // Error
//                  ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:54:18: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//       case const 0x0: // Error
//                  ^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:55:18: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//       case const 0.5: // Error
//                  ^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:56:18: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//       case const true: // Error
//                  ^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:57:18: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//       case const null: // Error
//                  ^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:58:18: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//       case const -0: // Error
//                  ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:59:18: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//       case const 'foo': // Error
//                  ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:60:18: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//       case const #a: // Error
//                  ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:61:18: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//       case const value: // Error
//                  ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:62:18: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//       case const local: // Error
//                  ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:63:25: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//       case const prefix.value: // Error
//                         ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:64:18: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//       case const -prefix.value: // Error
//                  ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:65:31: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//       case const prefix.Class.named: // Error
//                               ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:66:18: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//       case const 1 + 2: // Error
//                  ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:66:20: Error: Expected ':' before this.
//       case const 1 + 2: // Error
//                    ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:66:20: Error: '+' is not a prefix operator.
// Try removing '+'.
//       case const 1 + 2: // Error
//                    ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:66:22: Error: Expected ';' after this.
//       case const 1 + 2: // Error
//                      ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:66:23: Error: Expected an identifier, but got ':'.
// Try inserting an identifier before ':'.
//       case const 1 + 2: // Error
//                       ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:66:23: Error: Unexpected token ':'.
//       case const 1 + 2: // Error
//                       ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:67:23: Error: A function expression can't have a name.
//       case const void fun() {}: // Error
//                       ^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:68:18: Error: `assert` can't be used as an expression.
//       case const assert(false): // Error
//                  ^^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:69:26: Error: Not a constant expression.
//       case const switch (o) { _ => true }: // Error
//                          ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:71:18: Error: The unary operator ! is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//       case const !false: // Error
//                  ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:72:18: Error: The unary operator ~ is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//       case const ~0: // Error
//                  ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:73:20: Error: Not a constant expression.
//       case const ++variable: // Error
//                    ^^^^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:86:18: Error: Duplicate 'const' keyword in constant expression.
// Try removing one of the 'const' keywords.
//       case const const Class(): // Error
//                  ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:87:18: Error: Duplicate 'const' keyword in constant expression.
// Try removing one of the 'const' keywords.
//       case const const Class(0): // Error
//                  ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:88:18: Error: Duplicate 'const' keyword in constant expression.
// Try removing one of the 'const' keywords.
//       case const const GenericClass(): // Error
//                  ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:89:18: Error: Duplicate 'const' keyword in constant expression.
// Try removing one of the 'const' keywords.
//       case const const GenericClass(a: 0): // Error
//                  ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:90:18: Error: Duplicate 'const' keyword in constant expression.
// Try removing one of the 'const' keywords.
//       case const const GenericClass<int>(): // Error
//                  ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:91:18: Error: Duplicate 'const' keyword in constant expression.
// Try removing one of the 'const' keywords.
//       case const const GenericClass<int>(a: 0): // Error
//                  ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:92:18: Error: Duplicate 'const' keyword in constant expression.
// Try removing one of the 'const' keywords.
//       case const const []: // Error
//                  ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:93:18: Error: Duplicate 'const' keyword in constant expression.
// Try removing one of the 'const' keywords.
//       case const const <int>[]: // Error
//                  ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:94:18: Error: Duplicate 'const' keyword in constant expression.
// Try removing one of the 'const' keywords.
//       case const const {}: // Error
//                  ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:95:18: Error: Duplicate 'const' keyword in constant expression.
// Try removing one of the 'const' keywords.
//       case const const <int, String>{}: // Error
//                  ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:96:18: Error: New expression is not a constant expression.
//       case const new Class(): // Error
//                  ^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:97:12: Error: New expression is not a constant expression.
//       case new Class(): // Error
//            ^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:98:18: Error: The empty record literal is not supported as a constant pattern.
//       case const (): // Error
//                  ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:99:18: Error: Duplicate 'const' keyword in constant expression.
// Try removing one of the 'const' keywords.
//       case const const (): // Error
//                  ^^^^^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:105:24: Error: This expression is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//       case GenericClass<int>: // Error
//                        ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:106:31: Error: This expression is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//       case prefix.GenericClass<int>: // Error
//                               ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:107:24: Error: This expression is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//       case GenericClass<int>.new: // Error
//                        ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:108:31: Error: This expression is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//       case prefix.GenericClass<int>.new: // Error
//                               ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:109:30: Error: This expression is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//       case const GenericClass<int>: // Error
//                              ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:110:37: Error: This expression is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//       case const prefix.GenericClass<int>: // Error
//                                     ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:24:12: Error: Not a constant expression.
//       case this: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:25:12: Error: Not a constant expression.
//       case this(): // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:48:12: Error: Not a constant expression.
//       case switch (o) { _ => true }: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:49:12: Error: Not a constant expression.
//       case await 0: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:67:18: Error: Not a constant expression.
//       case const void fun() {}: // Error
//                  ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:69:18: Error: Not a constant expression.
//       case const switch (o) { _ => true }: // Error
//                  ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:70:18: Error: Not a constant expression.
//       case const await 0: // Error
//                  ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:96:22: Error: New expression is not a constant expression.
//       case const new Class(): // Error
//                      ^
//
// pkg/front_end/testcases/patterns/const_patterns.dart:97:16: Error: New expression is not a constant expression.
//       case new Class(): // Error
//                ^
//
import self as self;
import "dart:core" as core;

import "org-dartlang-testcase:///const_patterns.dart" as prefix;

class Class extends core::Object /*hasConstConstructor*/  {
  const constructor •([dynamic a = #C1]) → self::Class
    : super core::Object::•()
    ;
  const constructor named() → self::Class
    : super core::Object::•()
    ;
  method call() → dynamic {}
  method test(dynamic o) → dynamic async /* futureValueType= dynamic */ {
    dynamic variable = 0;
    #L1:
    {
      void fun;
      final dynamic #2#0 = o;
      final const self::Class #2#5 = invalid-expression "Not a constant expression.";
      final const dynamic #2#7 = invalid-expression "Not a constant expression.";
      final const invalid-type #2#9 = invalid-expression "pkg/front_end/testcases/patterns/const_patterns.dart:26:12: Error: Method invocation is not a constant expression.
      case super(): // Error
           ^^^^";
      final const invalid-type #2#52 = invalid-expression "pkg/front_end/testcases/patterns/const_patterns.dart:47:12: Error: `assert` can't be used as an expression.
      case assert(false): // Error
           ^^^^^^";
      final const core::bool #2#54 = invalid-expression "Not a constant expression.";
      final const core::int #2#56 = invalid-expression "Not a constant expression.";
      final const invalid-type #2#62 = invalid-expression "pkg/front_end/testcases/patterns/const_patterns.dart:52:14: Error: Not a constant expression.
      case ++variable: // Error
             ^^^^^^^^";
      final const invalid-type #2#92 = invalid-expression "Not a constant expression.";
      final const invalid-type #2#94 = invalid-expression "pkg/front_end/testcases/patterns/const_patterns.dart:68:18: Error: `assert` can't be used as an expression.
      case const assert(false): // Error
                 ^^^^^^";
      final const core::bool #2#96 = invalid-expression "Not a constant expression.";
      final const core::int #2#98 = invalid-expression "Not a constant expression.";
      final const invalid-type #2#104 = invalid-expression "pkg/front_end/testcases/patterns/const_patterns.dart:73:20: Error: Not a constant expression.
      case const ++variable: // Error
                   ^^^^^^^^";
      final const self::Class #2#150 = invalid-expression "New expression is not a constant expression.";
      final const self::Class #2#152 = invalid-expression "New expression is not a constant expression.";
      if(#C2 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #2#0 == null || invalid-expression "Not a constant expression." =={core::Object::==}{(core::Object) → core::bool} #2#0 || invalid-expression "Not a constant expression." =={core::Object::==}{(core::Object) → core::bool} #2#0 || invalid-expression "pkg/front_end/testcases/patterns/const_patterns.dart:26:12: Error: Method invocation is not a constant expression.
      case super(): // Error
           ^^^^" =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C3 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C4 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C5 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C6 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C7 =={core::String::==}{(core::Object) → core::bool} #2#0 || #C8 =={core::String::==}{(core::Object) → core::bool} #2#0 || #C3 =={core::num::==}{(core::Object) → core::bool} #2#0 || (let final dynamic #t1 = #2#0! in #C3 =={core::num::==}{(core::Object) → core::bool} #2#0!) || (!(#2#0 == null) ?{core::bool} #C3 =={core::num::==}{(core::Object) → core::bool} #2#0 : false) || (let final dynamic #t2 = #2#0 as{ForNonNullableByDefault} core::int in #C3 =={core::num::==}{(core::Object) → core::bool} #2#0 as{ForNonNullableByDefault} core::int) || #C4 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C9 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C9 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C10 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C3 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C4 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C11 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C12 =={core::num::==}{(core::Object) → core::bool} #2#0) {
        {
          invalid-expression "pkg/front_end/testcases/patterns/const_patterns.dart:44:14: Error: This couldn't be parsed.
      case 1 + 2: // Error
             ^"{<invalid>}.+(2);
          invalid-expression "pkg/front_end/testcases/patterns/const_patterns.dart:44:17: Error: This couldn't be parsed.
      case 1 + 2: // Error
                ^";
          break #L1;
        }
      }
      else
        if(#C12 =={core::num::==}{(core::Object) → core::bool} #2#0) {
          {
            invalid-expression "pkg/front_end/testcases/patterns/const_patterns.dart:45:14: Error: This couldn't be parsed.
      case 1 * 2: // Error
             ^"{<invalid>}.*(2);
            invalid-expression "pkg/front_end/testcases/patterns/const_patterns.dart:45:17: Error: This couldn't be parsed.
      case 1 * 2: // Error
                ^";
            break #L1;
          }
        }
        else
          if(#2#0{core::int} is{ForNonNullableByDefault} void && (let final dynamic #t3 = fun = #2#0{core::int} in true)) {
            {
              () → Null {};
              invalid-expression "pkg/front_end/testcases/patterns/const_patterns.dart:46:25: Error: This couldn't be parsed.
      case void fun() {}: // Error
                        ^";
              break #L1;
            }
          }
          else
            if(invalid-expression "pkg/front_end/testcases/patterns/const_patterns.dart:47:12: Error: `assert` can't be used as an expression.
      case assert(false): // Error
           ^^^^^^" =={core::Object::==}{(core::Object) → core::bool} #2#0 || invalid-expression "Not a constant expression." =={core::Object::==}{(core::Object) → core::bool} #2#0 || invalid-expression "Not a constant expression." =={core::num::==}{(core::Object) → core::bool} #2#0 || #C2 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C13 =={core::num::==}{(core::Object) → core::bool} #2#0 || invalid-expression "pkg/front_end/testcases/patterns/const_patterns.dart:52:14: Error: Not a constant expression.
      case ++variable: // Error
             ^^^^^^^^" =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C9 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C9 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C14 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C2 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #2#0 == null || #C9 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C7 =={core::String::==}{(core::Object) → core::bool} #2#0 || #C15 =={core::Symbol::==}{(core::Object) → core::bool} #2#0 || #C3 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C9 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C3 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C4 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C11 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C12 =={core::num::==}{(core::Object) → core::bool} #2#0) {
              {
                invalid-expression "pkg/front_end/testcases/patterns/const_patterns.dart:66:20: Error: This couldn't be parsed.
      case const 1 + 2: // Error
                   ^"{<invalid>}.+(2);
                invalid-expression "pkg/front_end/testcases/patterns/const_patterns.dart:66:23: Error: This couldn't be parsed.
      case const 1 + 2: // Error
                      ^";
                break #L1;
              }
            }
            else
              if(invalid-expression "Not a constant expression." =={core::Object::==}{(core::Object) → core::bool} #2#0 || invalid-expression "pkg/front_end/testcases/patterns/const_patterns.dart:68:18: Error: `assert` can't be used as an expression.
      case const assert(false): // Error
                 ^^^^^^" =={core::Object::==}{(core::Object) → core::bool} #2#0 || invalid-expression "Not a constant expression." =={core::Object::==}{(core::Object) → core::bool} #2#0 || invalid-expression "Not a constant expression." =={core::num::==}{(core::Object) → core::bool} #2#0 || #C2 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C13 =={core::num::==}{(core::Object) → core::bool} #2#0 || invalid-expression "pkg/front_end/testcases/patterns/const_patterns.dart:73:20: Error: Not a constant expression.
      case const ++variable: // Error
                   ^^^^^^^^" =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C16 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C16 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C17 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C17 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C18 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C18 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C18 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C18 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C19 =={core::List::==}{(core::Object) → core::bool} #2#0 || #C20 =={core::List::==}{(core::Object) → core::bool} #2#0 || #C21 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C22 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C16 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C16 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C17 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C17 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C18 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C18 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C19 =={core::List::==}{(core::Object) → core::bool} #2#0 || #C20 =={core::List::==}{(core::Object) → core::bool} #2#0 || #C21 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C22 =={core::Object::==}{(core::Object) → core::bool} #2#0 || invalid-expression "New expression is not a constant expression." =={core::Object::==}{(core::Object) → core::bool} #2#0 || invalid-expression "New expression is not a constant expression." =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C23 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C23 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C12 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C13 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C3 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C4 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C24 =={core::num::==}{(core::Object) → core::bool} #2#0 || #C25 =={core::Type::==}{(core::Object) → core::bool} #2#0 || #C25 =={core::Type::==}{(core::Object) → core::bool} #2#0 || #C27 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C27 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C25 =={core::Type::==}{(core::Object) → core::bool} #2#0 || #C25 =={core::Type::==}{(core::Object) → core::bool} #2#0 || #C25 =={core::Type::==}{(core::Object) → core::bool} #2#0 || #C25 =={core::Type::==}{(core::Object) → core::bool} #2#0 || #C27 =={core::Object::==}{(core::Object) → core::bool} #2#0 || #C27 =={core::Object::==}{(core::Object) → core::bool} #2#0) {
                {
                  core::print(0);
                }
              }
    }
  }
}
class GenericClass<T extends core::Object? = dynamic> extends core::Object /*hasConstConstructor*/  {
  const constructor •({dynamic a = #C1}) → self::GenericClass<self::GenericClass::T%>
    : super core::Object::•()
    ;
}
static const field core::int value = #C3;
static method func() → void {}

constants  {
  #C1 = null
  #C2 = true
  #C3 = 42
  #C4 = -42
  #C5 = 42.5
  #C6 = -42.5
  #C7 = "foo"
  #C8 = "foobar"
  #C9 = 0
  #C10 = static-tearoff self::func
  #C11 = constructor-tearoff self::Class::named
  #C12 = 1
  #C13 = -1
  #C14 = 0.5
  #C15 = #a
  #C16 = self::Class {}
  #C17 = self::GenericClass<dynamic> {}
  #C18 = self::GenericClass<core::int> {}
  #C19 = <dynamic>[]
  #C20 = <core::int>[]
  #C21 = <dynamic, dynamic>{)
  #C22 = <core::int, core::String>{)
  #C23 = ()
  #C24 = 3
  #C25 = TypeLiteralConstant(self::GenericClass<core::int>)
  #C26 = constructor-tearoff self::GenericClass::•
  #C27 = instantiation #C26 <core::int>
}


Constructor coverage from constants:
org-dartlang-testcase:///const_patterns.dart:
- Class. (from org-dartlang-testcase:///const_patterns.dart:12:9)
- Object. (from org-dartlang-sdk:///sdk/lib/core/object.dart)
- GenericClass. (from org-dartlang-testcase:///const_patterns.dart:121:9)
