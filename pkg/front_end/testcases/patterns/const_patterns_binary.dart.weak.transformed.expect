library /*isNonNullableByDefault*/;
//
// Problems in library:
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:19:12: Error: The binary operator + is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 + 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:20:12: Error: The binary operator - is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 - 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:21:12: Error: The binary operator * is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 * 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:22:12: Error: The binary operator / is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 / 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:23:12: Error: The binary operator ~/ is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 ~/ 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:24:12: Error: The binary operator % is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 % 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:25:12: Error: The binary operator == is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 == 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:26:12: Error: The binary operator != is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 != 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:27:12: Error: The binary operator ^ is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 ^ 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:28:12: Error: The binary operator & is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 & 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:29:12: Error: The binary operator | is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 | 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:30:12: Error: The binary operator < is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 < 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:31:12: Error: The binary operator <= is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 <= 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:32:12: Error: The binary operator > is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 > 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:33:12: Error: The binary operator >= is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 >= 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:34:12: Error: The binary operator << is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 << 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:35:12: Error: The binary operator >> is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 >> 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:36:12: Error: The binary operator >>> is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 >>> 2: // Error
//            ^^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:37:12: Error: The binary operator + is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 + 2 + 3: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:40:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 as int: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:41:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 + 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:42:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 - 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:43:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 * 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:44:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 / 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:45:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 ~/ 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:46:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 % 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:47:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 == 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:48:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 != 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:49:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 ^ 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:50:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 & 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:51:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 | 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:52:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 < 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:53:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 <= 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:54:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 > 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:55:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 >= 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:56:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 << 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:57:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 >> 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:58:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 >>> 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:59:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 + 2 + 3: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:60:23: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const Object() == 2: // Error
//                       ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:81:12: Error: Expected ':' before this.
//     case 1 ?? 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:81:12: Error: Expected an identifier, but got '??'.
// Try inserting an identifier before '??'.
//     case 1 ?? 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:81:15: Error: Expected ';' after this.
//     case 1 ?? 2: // Error
//               ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:81:16: Error: Expected an identifier, but got ':'.
// Try inserting an identifier before ':'.
//     case 1 ?? 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:81:16: Error: Unexpected token ':'.
//     case 1 ?? 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:82:10: Error: Not a constant expression.
//     case o++: // Error
//          ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:83:10: Error: Not a constant expression.
//     case o--: // Error
//          ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:84:12: Error: Not a constant expression.
//     case ++o: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:85:12: Error: Not a constant expression.
//     case --o: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:60:25: Error: Constant evaluation error:
//     case const Object() == 2: // Error
//                         ^
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:60:25: Context: Binary operator '==' requires receiver constant 'Object {}' of type 'Null', 'bool', 'int', 'double', or 'String', but was of type 'Object'.
//  - 'Object' is from 'dart:core'.
//     case const Object() == 2: // Error
//                         ^
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:60:25: Context: While analyzing:
//     case const Object() == 2: // Error
//                         ^
//
import self as self;
import "dart:core" as core;

import "org-dartlang-testcase:///const_patterns_binary.dart" as prefix;

class Class extends core::Object {
  static const field core::int value = #C1;
  synthetic constructor •() → self::Class
    : super core::Object::•()
    ;
}
static const field core::int value = #C2;
static method method<T extends core::Object? = dynamic>(dynamic o) → dynamic {
  #L1:
  {
    final dynamic #0#0 = o;
    final const core::bool #0#97 = invalid-expression "Binary operator '==' requires receiver constant 'Object {}' of type 'Null', 'bool', 'int', 'double', or 'String', but was of type 'Object'.
 - 'Object' is from 'dart:core'.";
    final const invalid-type #0#142 = invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:82:10: Error: Not a constant expression.
    case o++: // Error
         ^";
    final const invalid-type #0#144 = invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:83:10: Error: Not a constant expression.
    case o--: // Error
         ^";
    final const invalid-type #0#146 = invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:84:12: Error: Not a constant expression.
    case ++o: // Error
           ^";
    final const invalid-type #0#148 = invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:85:12: Error: Not a constant expression.
    case --o: // Error
           ^";
    if(#C2 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C1 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C2 =={core::num::==}{(core::Object) → core::bool} #0#0 && #C1 =={core::num::==}{(core::Object) → core::bool} #0#0 || (let final self::method::T% #t1 = #0#0 as{ForNonNullableByDefault} self::method::T% in #C2 =={core::num::==}{(core::Object) → core::bool} #0#0 as{ForNonNullableByDefault} self::method::T%) || #C3 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C4 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C5 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C1 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C6 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C7 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C2 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C4 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C7 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C4 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C10 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C7 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C7 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C11 =={core::num::==}{(core::Object) → core::bool} #0#0 || (let final self::method::T% #t2 = #0#0 as{ForNonNullableByDefault} self::method::T% in #C2 =={core::num::==}{(core::Object) → core::bool} #0#0 as{ForNonNullableByDefault} self::method::T%) || (let final self::method::T% #t3 = #0#0 as{ForNonNullableByDefault} self::method::T% in #C1 =={core::num::==}{(core::Object) → core::bool} #0#0 as{ForNonNullableByDefault} self::method::T%) || (let final core::int #t4 = #0#0 as{ForNonNullableByDefault} core::int in #C2 =={core::num::==}{(core::Object) → core::bool} #0#0 as{ForNonNullableByDefault} core::int) || #C4 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C5 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C1 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C6 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C7 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C2 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C4 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C7 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C4 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C10 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C7 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C7 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C11 =={core::num::==}{(core::Object) → core::bool} #0#0 || invalid-expression "Binary operator '==' requires receiver constant 'Object {}' of type 'Null', 'bool', 'int', 'double', or 'String', but was of type 'Object'.
 - 'Object' is from 'dart:core'." =={core::Object::==}{(core::Object) → core::bool} #0#0 || (let final core::List<self::method::T%> #t5 = #0#0 as{ForNonNullableByDefault} core::List<self::method::T%> in #C12 =={core::List::==}{(core::Object) → core::bool} #0#0 as{ForNonNullableByDefault} core::List<self::method::T%>) || #C4 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C5 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C1 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C6 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C7 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C2 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C4 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C7 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C4 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0 || #C10 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C7 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C7 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C11 =={core::num::==}{(core::Object) → core::bool} #0#0 || #C2 =={core::num::==}{(core::Object) → core::bool} #0#0) {
      {
        let final invalid-type #t6 = invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:81:12: Error: This couldn't be parsed.
    case 1 ?? 2: // Error
           ^" in #t6 == null ?{invalid-type} 2 : #t6;
        invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:81:16: Error: This couldn't be parsed.
    case 1 ?? 2: // Error
               ^";
        break #L1;
      }
    }
    else
      if(invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:82:10: Error: Not a constant expression.
    case o++: // Error
         ^" =={core::Object::==}{(core::Object) → core::bool} #0#0 || invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:83:10: Error: Not a constant expression.
    case o--: // Error
         ^" =={core::Object::==}{(core::Object) → core::bool} #0#0 || invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:84:12: Error: Not a constant expression.
    case ++o: // Error
           ^" =={core::Object::==}{(core::Object) → core::bool} #0#0 || invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:85:12: Error: Not a constant expression.
    case --o: // Error
           ^" =={core::Object::==}{(core::Object) → core::bool} #0#0) {
      }
  }
}

constants  {
  #C1 = 2
  #C2 = 1
  #C3 = core::Object {}
  #C4 = 3
  #C5 = -1
  #C6 = 0.5
  #C7 = 0
  #C8 = false
  #C9 = true
  #C10 = 4
  #C11 = 6
  #C12 = <core::int*>[]
}


Constructor coverage from constants:
org-dartlang-testcase:///const_patterns_binary.dart:
- Object. (from org-dartlang-sdk:///sdk/lib/core/object.dart)
